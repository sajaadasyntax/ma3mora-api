generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  SALES_GROCERY
  SALES_BAKERY
  INVENTORY
  PROCUREMENT
  ACCOUNTANT
  AUDITOR
  MANAGER
}

enum Section {
  GROCERY
  BAKERY
}

enum CustomerType {
  WHOLESALE
  RETAIL
}

enum PaymentMethod {
  CASH
  BANK
  BANK_NILE
}

enum PaymentStatus {
  PAID
  PARTIAL
  CREDIT
}

enum DeliveryStatus {
  NOT_DELIVERED
  PARTIAL
  DELIVERED
}

enum ProcOrderStatus {
  CREATED
  RECEIVED
  PARTIAL
  CANCELLED
}

enum BalanceScope {
  CASHBOX
  CUSTOMER
  SUPPLIER
}

model User {
  id           String   @id @default(cuid())
  username     String   @unique
  passwordHash String
  role         Role
  sessionToken String?  @unique
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  accesses               UserInventoryAccess[]
  salesInvoices          SalesInvoice[]
  procOrders             ProcOrder[]
  expenses               Expense[]
  auditLogs              AuditLog[]
  salesPayments          SalesPayment[]
  inventoryDelivery      InventoryDelivery[]
  inventoryReceipt       InventoryReceipt[]
  paymentConfirmedOrders ProcOrder[]          @relation("PaymentConfirmer")
  paymentConfirmedInvoices SalesInvoice[]     @relation("InvoicePaymentConfirmer")
  procOrderPayments      ProcOrderPayment[]
  procOrderReturns       ProcOrderReturn[]
  inventoryTransfers     InventoryTransfer[]
  salaries               Salary[]
  advances               Advance[]
  cashExchanges          CashExchange[]
  refundedOrders         ProcOrder[]         @relation("OrderRefunder")

  @@map("users")
}

model Inventory {
  id     String  @id @default(cuid())
  name   String  @unique
  isMain Boolean @default(false)

  accesses          UserInventoryAccess[]
  stocks            InventoryStock[]
  batches           StockBatch[]
  salesInvoices     SalesInvoice[]
  procOrders        ProcOrder[]
  expenses          Expense[]
  transfersFrom     InventoryTransfer[] @relation("FromInventory")
  transfersTo       InventoryTransfer[] @relation("ToInventory")
  stockMovements    StockMovement[]

  @@map("inventories")
}

model UserInventoryAccess {
  userId      String
  inventoryId String
  section     Section

  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  inventory Inventory @relation(fields: [inventoryId], references: [id], onDelete: Cascade)

  @@id([userId, inventoryId, section])
  @@map("user_inventory_access")
}

model Item {
  id        String   @id @default(cuid())
  name      String
  section   Section
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  prices            ItemPrice[]
  stocks            InventoryStock[]
  batches           StockBatch[]
  transfers         InventoryTransfer[]
  movements         StockMovement[]
  salesInvoiceItems SalesInvoiceItem[]
  procOrderItems    ProcOrderItem[]
  deliveryItems     InventoryDeliveryItem[]

  @@map("items")
}

model ItemPrice {
  id        String       @id @default(cuid())
  itemId    String
  tier      CustomerType
  price     Decimal      @db.Decimal(10, 2)
  validFrom DateTime     @default(now())

  item Item @relation(fields: [itemId], references: [id], onDelete: Cascade)

  @@index([itemId, tier])
  @@map("item_prices")
}

model InventoryStock {
  inventoryId String
  itemId      String
  quantity    Decimal @default(0) @db.Decimal(10, 2)

  inventory Inventory @relation(fields: [inventoryId], references: [id], onDelete: Cascade)
  item      Item      @relation(fields: [itemId], references: [id], onDelete: Cascade)
  batches   StockBatch[]

  @@id([inventoryId, itemId])
  @@map("inventory_stocks")
}

model StockBatch {
  id           String   @id @default(cuid())
  inventoryId  String
  itemId       String
  quantity     Decimal  @db.Decimal(10, 2)
  expiryDate   DateTime?
  receivedAt   DateTime @default(now())
  receiptId    String?
  notes        String?

  inventory       Inventory       @relation(fields: [inventoryId], references: [id], onDelete: Cascade)
  item            Item            @relation(fields: [itemId], references: [id], onDelete: Cascade)
  inventoryStock  InventoryStock? @relation(fields: [inventoryId, itemId], references: [inventoryId, itemId], onDelete: Cascade)
  receipt         InventoryReceipt? @relation(fields: [receiptId], references: [id], onDelete: SetNull)
  deliveryBatches InventoryDeliveryBatch[]

  @@index([inventoryId, itemId])
  @@index([expiryDate])
  @@index([receiptId])
  @@map("stock_batches")
}

model InventoryTransfer {
  id         String   @id @default(cuid())
  fromInventoryId String
  toInventoryId   String
  itemId          String
  quantity        Decimal @db.Decimal(10, 2)
  transferredBy   String
  transferredAt   DateTime @default(now())
  notes           String?

  fromInventory Inventory @relation("FromInventory", fields: [fromInventoryId], references: [id])
  toInventory   Inventory @relation("ToInventory", fields: [toInventoryId], references: [id])
  item          Item      @relation(fields: [itemId], references: [id])
  transferredByUser User  @relation(fields: [transferredBy], references: [id])

  @@map("inventory_transfers")
}

// Stock Movement Daily Report Model
// Tracks daily stock movements for inventory items
// Fields: openingBalance (stock at start of day), incoming (from procurement), 
// outgoing (sold and delivered), pendingOutgoing (sold but not delivered),
// incomingGifts (gifts received), outgoingGifts (gifts given), closingBalance (stock at end of day)
model StockMovement {
  id            String   @id @default(cuid())
  inventoryId   String
  itemId        String
  movementDate  DateTime @db.Date
  openingBalance Decimal @db.Decimal(10, 2)  // Opening stock balance at start of day
  incoming      Decimal  @default(0) @db.Decimal(10, 2)  // Stock received from procurement
  outgoing      Decimal  @default(0) @db.Decimal(10, 2)  // Stock sold and delivered
  pendingOutgoing Decimal @default(0) @db.Decimal(10, 2)  // Stock sold but not yet delivered
  incomingGifts Decimal  @default(0) @db.Decimal(10, 2)  // Gifts received (from procurement)
  outgoingGifts Decimal  @default(0) @db.Decimal(10, 2)  // Gifts given (from sales)
  closingBalance Decimal @db.Decimal(10, 2)  // Closing stock balance at end of day
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  inventory Inventory @relation(fields: [inventoryId], references: [id], onDelete: Cascade)
  item      Item      @relation(fields: [itemId], references: [id], onDelete: Cascade)

  @@unique([inventoryId, itemId, movementDate])
  @@index([movementDate])
  @@index([inventoryId, itemId])
  @@map("stock_movements")
}

model Customer {
  id        String       @id @default(cuid())
  name      String
  type      CustomerType
  division  Section
  phone     String?
  address   String?
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt

  salesInvoices  SalesInvoice[]
  openingBalance OpeningBalance[]

  @@map("customers")
}

model Supplier {
  id        String   @id @default(cuid())
  name      String
  phone     String?
  address   String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  procOrders     ProcOrder[]
  openingBalance OpeningBalance[]

  @@map("suppliers")
}

model SalesInvoice {
  id                 String         @id @default(cuid())
  invoiceNumber      String         @unique
  inventoryId        String
  section            Section
  salesUserId        String
  customerId         String?
  paymentMethod      PaymentMethod
  paymentStatus      PaymentStatus  @default(CREDIT)
  deliveryStatus     DeliveryStatus @default(NOT_DELIVERED)
  paymentConfirmed   Boolean        @default(false)
  paymentConfirmedBy String?
  paymentConfirmedAt DateTime?
  subtotal           Decimal        @db.Decimal(10, 2)
  discount           Decimal        @default(0) @db.Decimal(10, 2)
  total              Decimal        @db.Decimal(10, 2)
  paidAmount         Decimal        @default(0) @db.Decimal(10, 2)
  notes              String?
  createdAt          DateTime       @default(now())
  updatedAt          DateTime       @updatedAt

  inventory               Inventory @relation(fields: [inventoryId], references: [id])
  salesUser               User      @relation(fields: [salesUserId], references: [id])
  customer                Customer? @relation(fields: [customerId], references: [id])
  paymentConfirmedByUser  User?     @relation("InvoicePaymentConfirmer", fields: [paymentConfirmedBy], references: [id])

  items      SalesInvoiceItem[]
  payments   SalesPayment[]
  deliveries InventoryDelivery[]

  @@map("sales_invoices")
}

model SalesInvoiceItem {
  id        String  @id @default(cuid())
  invoiceId String
  itemId    String
  quantity  Decimal @db.Decimal(10, 2)
  giftQty   Decimal @default(0) @db.Decimal(10, 2)
  unitPrice Decimal @db.Decimal(10, 2)
  lineTotal Decimal @db.Decimal(10, 2)

  invoice SalesInvoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  item    Item         @relation(fields: [itemId], references: [id])

  @@map("sales_invoice_items")
}

model SalesPayment {
  id        String        @id @default(cuid())
  invoiceId String
  amount    Decimal       @db.Decimal(10, 2)
  method    PaymentMethod
  paidAt    DateTime      @default(now())
  recordedBy String
  notes     String?
  receiptUrl String?
  receiptNumber String?   @unique

  invoice    SalesInvoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  recordedByUser User     @relation(fields: [recordedBy], references: [id])

  @@map("sales_payments")
}

model InventoryDelivery {
  id         String   @id @default(cuid())
  invoiceId  String
  deliveredBy String
  deliveredAt DateTime @default(now())
  notes      String?

  invoice       SalesInvoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  deliveredByUser User       @relation(fields: [deliveredBy], references: [id])
  items          InventoryDeliveryItem[]

  @@map("inventory_deliveries")
}

model InventoryDeliveryItem {
  id           String   @id @default(cuid())
  deliveryId   String
  itemId       String
  quantity     Decimal  @db.Decimal(10, 2)
  giftQty      Decimal  @default(0) @db.Decimal(10, 2)

  delivery InventoryDelivery @relation(fields: [deliveryId], references: [id], onDelete: Cascade)
  item     Item               @relation(fields: [itemId], references: [id])
  batches  InventoryDeliveryBatch[]

  @@map("inventory_delivery_items")
}

model InventoryDeliveryBatch {
  id              String  @id @default(cuid())
  deliveryItemId  String
  batchId         String
  quantity        Decimal @db.Decimal(10, 2)

  deliveryItem InventoryDeliveryItem @relation(fields: [deliveryItemId], references: [id], onDelete: Cascade)
  batch        StockBatch             @relation(fields: [batchId], references: [id])

  @@map("inventory_delivery_batches")
}

model ProcOrder {
  id                 String           @id @default(cuid())
  orderNumber        String           @unique
  inventoryId        String
  section            Section
  createdBy          String
  supplierId         String
  status             ProcOrderStatus  @default(CREATED)
  total              Decimal          @db.Decimal(10, 2)
  paidAmount         Decimal          @default(0) @db.Decimal(10, 2)
  paymentConfirmed   Boolean          @default(false)
  paymentConfirmedBy String?
  paymentConfirmedAt DateTime?
  refundMethod       PaymentMethod?
  refundAmount       Decimal?         @db.Decimal(10, 2)
  refundNotes        String?
  refundedBy         String?
  refundedAt         DateTime?
  notes              String?
  createdAt          DateTime         @default(now())
  updatedAt          DateTime         @updatedAt

  inventory             Inventory @relation(fields: [inventoryId], references: [id])
  creator               User      @relation(fields: [createdBy], references: [id])
  supplier              Supplier  @relation(fields: [supplierId], references: [id])
  paymentConfirmedByUser User?    @relation("PaymentConfirmer", fields: [paymentConfirmedBy], references: [id])
  refundedByUser        User?     @relation("OrderRefunder", fields: [refundedBy], references: [id])

  items    ProcOrderItem[]
  payments ProcOrderPayment[]
  returns  ProcOrderReturn[]
  receipts InventoryReceipt[]

  @@map("proc_orders")
}

model ProcOrderItem {
  id       String  @id @default(cuid())
  orderId  String
  itemId   String
  quantity Decimal @db.Decimal(10, 2)
  giftQty  Decimal @default(0) @db.Decimal(10, 2)
  unitCost Decimal @db.Decimal(10, 2)
  lineTotal Decimal @db.Decimal(10, 2)

  order ProcOrder @relation(fields: [orderId], references: [id], onDelete: Cascade)
  item  Item      @relation(fields: [itemId], references: [id])

  @@map("proc_order_items")
}

model ProcOrderReturn {
  id         String   @id @default(cuid())
  orderId    String
  reason     String
  returnedBy String
  returnedAt DateTime @default(now())
  notes      String?

  order    ProcOrder @relation(fields: [orderId], references: [id], onDelete: Cascade)
  returnedByUser User     @relation(fields: [returnedBy], references: [id])

  @@map("proc_order_returns")
}

model ProcOrderPayment {
  id        String        @id @default(cuid())
  orderId   String
  amount    Decimal       @db.Decimal(10, 2)
  method    PaymentMethod
  paidAt    DateTime      @default(now())
  recordedBy String
  notes     String?
  receiptUrl String?
  receiptNumber String? @unique

  order    ProcOrder @relation(fields: [orderId], references: [id], onDelete: Cascade)
  recordedByUser User     @relation(fields: [recordedBy], references: [id])

  @@map("proc_order_payments")
}

model InventoryReceipt {
  id         String   @id @default(cuid())
  orderId    String
  receivedBy String
  receivedAt DateTime @default(now())
  notes      String?

  order         ProcOrder @relation(fields: [orderId], references: [id], onDelete: Cascade)
  receivedByUser User     @relation(fields: [receivedBy], references: [id])
  batches       StockBatch[]

  @@map("inventory_receipts")
}

model Expense {
  id          String        @id @default(cuid())
  inventoryId String?
  section     Section?
  amount      Decimal       @db.Decimal(10, 2)
  method      PaymentMethod
  description String
  createdBy   String
  createdAt   DateTime      @default(now())

  inventory Inventory? @relation(fields: [inventoryId], references: [id])
  creator   User       @relation(fields: [createdBy], references: [id])

  @@map("expenses")
}

model OpeningBalance {
  id            String        @id @default(cuid())
  scope         BalanceScope
  refId         String?
  amount        Decimal       @db.Decimal(10, 2)
  paymentMethod PaymentMethod @default(CASH)  // Track which payment method this balance is for (CASH, BANK, BANK_NILE)
  openedAt      DateTime      @default(now())
  closedAt      DateTime?
  isClosed      Boolean       @default(false)
  notes         String?

  customer Customer? @relation(fields: [refId], references: [id], map: "opening_balance_customer_fkey")
  supplier Supplier? @relation(fields: [refId], references: [id], map: "opening_balance_supplier_fkey")

  @@index([scope, isClosed, paymentMethod])
  @@map("opening_balances")
}

model AuditLog {
  id       String   @id @default(cuid())
  userId   String
  action   String
  entity   String
  entityId String
  before   String?
  after    String?
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id])

  @@index([entity, entityId])
  @@index([userId])
  @@map("audit_logs")
}

model Employee {
  id        String   @id @default(cuid())
  name      String
  position  String
  phone     String?
  address   String?
  salary    Decimal  @db.Decimal(10, 2)
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  salaries Salary[]
  advances Advance[]

  @@map("employees")
}

model Salary {
  id            String        @id @default(cuid())
  employeeId    String
  amount        Decimal       @db.Decimal(10, 2)
  month         Int
  year          Int
  paymentMethod PaymentMethod @default(CASH)
  paidAt        DateTime?
  notes         String?
  createdBy     String
  createdAt     DateTime      @default(now())

  employee Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  creator  User     @relation(fields: [createdBy], references: [id])

  @@unique([employeeId, month, year])
  @@map("salaries")
}

model Advance {
  id            String        @id @default(cuid())
  employeeId    String
  amount        Decimal       @db.Decimal(10, 2)
  reason        String
  paymentMethod PaymentMethod @default(CASH)
  paidAt        DateTime?
  notes         String?
  createdBy     String
  createdAt     DateTime      @default(now())

  employee Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  creator  User     @relation(fields: [createdBy], references: [id])

  @@map("advances")
}

model CashExchange {
  id            String        @id @default(cuid())
  amount        Decimal       @db.Decimal(10, 2)
  fromMethod    PaymentMethod
  toMethod      PaymentMethod
  receiptNumber String?       @unique
  receiptUrl    String?
  notes         String?
  createdBy     String
  createdAt     DateTime      @default(now())

  createdByUser User          @relation(fields: [createdBy], references: [id])

  @@map("cash_exchanges")
}

